Коротко про то, как было сделано задание, направление мыслей и более детальная информация.

0. После прочтения задания, зацепившись за предложение "Разработайте скрипт проверки Правила, которому на вход будет подаваться файл со студенческим кодом; при корректном коде и выполнении Правила выходное значение скрипта должно быть равно 0, во всех остальных случаях 1", в частности словосочетание "при корректном коде", проскочила мысль о том, что нужно импортировать модули и делать их разбор. ОШИБКА. Что если кто-то вставит `__import__('subprocess').getoutput('rm –rf *')` внутри модуля? Кому прилетит по шапке, думаю тут все очевидно :)
1. Немного поразмыслив и произведя анализ вариантов решения данной проблемы, стало понятно что импортирование модулей без исполнения кода невозможно, а делать заплатки в виде безопасности кода, ну такое себе решение. Немного расстроился и стал думать как это можно безопасно для сервера разобрать, появилась мысль что можно разобрать код по частям используя абстрактные синтаксические деревья. Проанализировав данные по запросу "Abstract Syntax Trees python", обнаружил, что есть встроенная библиотека AST для наших целей. Проверяем технические требования в виде версии питона. Заходим в документацию, смотрим версию 3.8, которая располагается по ссылке - https://docs.python.org/3.8/library/ast.html
2. Перечитав задание еще раз, стало понятно что про успешную интерпретацию кода не было ни слова, значит я двигаюсь в правильном направлении и этот вариант нам подходит.
3. Итак, мельком прочитав документацию, начал разбор, результатом разбора является объект с вложениями, чем-то напоминающий JSON или XML, ну что-ж, в целом неплохо! Осталось понять как делать обход с нужными правилами.
4. Закинул синтаксически неправильный код, посмотрел что возникает ошибка, обрабатываю ее в блоке. Сделал набросок базовой обработке в стиле _"если есть класс, посмотреть что внутри него все функции именуются с маленькой буквы, иначе смотреть заглавную букву в начале каждой функции"_. Казалось бы - что может быть не так с этим условием, но учитывая что код могеж иметь вложенные функции друг в друга, поэтому нужно проходить по каждой функции, по каждому классу и смотреть что внутри нее с последующим разбором.
5. Сразу же пришло в голову по обходу этой структуры - <a href="https://en.wikipedia.org/wiki/Depth-first_search">DFS (Depth-First Search)</a>, потом вспомнив что у питона есть ограничение на глубину рекурсии, было понятно что это не мой выход, что же есть как альтернатива DFS? Конечно же его брат-близнец - <a href="https://en.wikipedia.org/wiki/Breadth-first_search">BFS (Breadth-First Search)</a>. Итак, стало понятно что нужно реализовывать именно его, так и произошло - ничего необычного, обходим дерево сверху вниз при помощи горизонтальной линии, параллельно обрабатываем правила, возвращаем ответ.

PS:
<b>Как можно улучшить этот код? </b><br>
<i>- Посмотреть более детально библиотеку AST, в частности почитать про Visitor и Listener.</i>