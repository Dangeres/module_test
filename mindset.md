Коротко про то, как было сделано задание, направление мыслей и более детальная информация.

0. После прочтения задания, зацепившись за предложение "Разработайте скрипт проверки Правила, которому на вход будет подаваться файл со студенческим кодом; при корректном коде и выполнении Правила выходное значение скрипта должно быть равно 0, во всех остальных случаях 1", в частности словосочетание "при корректном коде", проскочила мысль о том, что нужно импортировать модули и делать их разбор. ОШИБКА. Что если кто-то вставит `__import__('subprocess').getoutput('rm –rf *')` внутри модуля? Кому прилетит по шапке, думаю тут все очевидно :)
1. Погуглив что импортирование модулей без исполнения кода невозможно, немного расстроился и стал думать как это можно безопасно для сервера разобрать, появилась мысль что можно разобрать код по частям используя абстрактные синтаксические деревья. Проходим в гугл, запрос "Abstract Syntax Trees python", первая ссылка - официальный сайт питона с документацией по необходимой библиотеке. Смотрим версию питона 3.8, обнаруживаем что она имеется. Вот оно - https://docs.python.org/3.8/library/ast.html
2. Перечитав задание еще раз, стало понятно что про успешную интерпретацию кода не было ни слова, значит я двигаюсь в правильном направлении.
3. Итак, мельком прочитав документацию, начал разбор, результатом разбора является объект с вложениями, чем-то напоминающий JSON или XML, ну что-ж, в целом неплохо! Осталось понять как делать обход с нужными правилами.
4. Накидал базовую обработку в стиле _"если есть класс, посмотреть что внутри него все функции именуются с маленькой буквы, иначе смотреть заглавную букву в начале"_. Казалось бы - что может быть не так с этим условием, но учитывая что код пишут люди, могут писать вложенные функции друг в друга, поэтому нужно проходить по каждой функции, по каждому классу и смотреть что внутри с последующим разбором.
5. Сразу же пришло в голову по обходу этой структуры - <a href="https://en.wikipedia.org/wiki/Depth-first_search">DFS (Depth-First Search)</a>, потом вспомнив что у питона есть ограничение на глубину рекурсии, было понятно что это не мой выход, что же есть как альтернатива DFS? Конечно же его брат-близнец - <a href="https://en.wikipedia.org/wiki/Breadth-first_search">BFS (Breadth-First Search)</a>. Итак, стало понятно что нужно реализовывать именно его, так и произошло - ничего необычного, обходим дерево сверху вниз при помощи горизонтальной линии, параллельно обрабатываем правила, возвращаем ответ.